/*******************************************************************************************
  SIMPL+ Module Information
  (Fill in comments below)
*******************************************************************************************/
/*
Dealer Name:	Crestron Electronics, Inc.
System Name:	NTP Time Sync	

Comments:
For a description of this module and a history of revisions, please see the #HELP section
below.

The structure of an SNTP v4 packet (see RFC2030):

                           1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |LI | VN  |Mode |    Stratum    |     Poll      |   Precision   |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                          Root Delay                           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                       Root Dispersion                         |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                     Reference Identifier                      |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      |                   Reference Timestamp (64)                    |
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      |                   Originate Timestamp (64)                    |
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      |                    Receive Timestamp (64)                     |
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      |                    Transmit Timestamp (64)                    |
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

	NOTE:	The optional Key Identifier and Message Digest fields are
			not shown since they are not used by this module.

*/

/*******************************************************************************************
  Compiler Directives
  (Uncomment and declare compiler directives as needed)
*******************************************************************************************/
// #SYMBOL_NAME ""
// #HINT "NTPClient"

#DEFINE_CONSTANT	NUM_SERVERS	4		//number of servers this module supports
#DEFINE_CONSTANT	NTP_PORT	123		//standard UDP port for NTP
#DEFINE_CONSTANT	PKT_SIZE	48		//size of an SNTP packet (see structure above)
#DEFINE_CONSTANT	UDP_TIMEOUT	500		//server timeout (500 = 5 seconds)

//#CATEGORY "16" // Time/Date
#CATEGORY "0" // Hidden

#DEFAULT_VOLATILE
//#DEFAULT_NONVOLATILE

// #DIGITAL_EXPAND 
// #ANALOG_SERIAL_EXPAND 
// #OUTPUT_SHIFT 
#ENABLE_STACK_CHECKING

//#ENABLE_TRACE
//#PRINT_TO_TRACE


#HELP_BEGIN
Enables a Crestron control system to set its clock based on the value it
retrieves from an NTP (Network Time Protocol) server.  Currently it supports
communication with up to four NTP servers.  This module implements the SNTP v4
specification which is described in RFC2030.

A list of public NTP servers can be found here: http://ntp.isc.org/bin/view/Servers/WebHome
                 
Revision History:
v1.0 - Initial
#HELP_END


/*******************************************************************************************
  Include Libraries
  (Uncomment and include additional librarys as needed)
*******************************************************************************************/
// #CRESTRON_LIBRARY ""
// #USER_LIBRARY ""

/*******************************************************************************************
  DIGITAL, ANALOG and SERIAL INPUTS and OUTPUTS
  (Uncomment and declare inputs and outputs as needed)
*******************************************************************************************/
DIGITAL_INPUT	Debug,
				Logging,
				_SKIP_,
				SyncTime[NUM_SERVERS];

ANALOG_INPUT	_SKIP_,
				_SKIP_,
				_SKIP_,
				_SKIP_,
				_SKIP_,
				_SKIP_,
				GMT_Offset_Minutes;

STRING_INPUT	_SKIP_,
				Server_IP$[NUM_SERVERS][64];

DIGITAL_OUTPUT	Busy,
				_SKIP_,
				_SKIP_,
				SyncSuccessful[NUM_SERVERS],
				_SKIP_,
				SyncFailed[NUM_SERVERS];

UDP_SOCKET		NTPServer[256];

/*******************************************************************************************
  Global Variables
  (Uncomment and declare global variables as needed)
  Note:  Be sure to initialize all declared STRING variables as needed
         For example, in Function Main: myString = "";
*******************************************************************************************/
INTEGER	currServer;

STRING	tempRxIP$[16],
		tempStamp$[8];

/*******************************************************************************************
  Functions
  (Add any additional functions here)
  Note:  Functions must be physically placed before the location in
         the code that calls them.
*******************************************************************************************/

//returns 1 if year is a leap year, 0 otherwise
INTEGER_FUNCTION isLeapYear(INTEGER year)
{
    if ((year MOD 400) = 0)
		return(1);

	else if ((year MOD 100) = 0)
		return(0);

	else if ((year MOD 4) = 0)
		return(1);

	else
		return(0);
}

//returns the number of days in the specified month, based on the year
//january = 1, december = 12
//this is some comp sci 101 shit but it works...
INTEGER_FUNCTION daysInMonth(INTEGER mon, INTEGER year)
{
	//april, june, sept, and nov all have 30 days
	if ((mon = 4) || (mon = 6) || (mon = 9) || (mon = 11))
		return(30);

	//february
	else if (mon = 2)
        if(isLeapYear(year))
			return(29);
		else
			return(28);
    
	//all other (including invalid) months
	else
		return(31);
}


//converts a 32-bit long integer to a 4-byte string
STRING_FUNCTION longToStr(LONG_INTEGER val)
{
	INTEGER hword, lword;
	STRING data$[4];
	
	ClearBuffer(data$);

	hword = HighWord(val);
    lword = LowWord(val);

	data$ = chr(High(hword)) 
			+ chr(low(hword))
			+ chr(high(lword))
			+ chr(low(lword));

	return(data$);
}

//takes the first 4 bytes of the passed string and converts them to a 32-bit long integer
LONG_INTEGER_FUNCTION strToLong(STRING str$)
{
	LONG_INTEGER val;

	if (len(str$) < 4)
		return(0);

	val = byte(str$, 4);
	val = val + (byte(str$, 3) << 8);
	val = val + (byte(str$, 2) << 16);
	val = val + (byte(str$, 1) << 24);
	
	return(val);
}

//returns a 64-bit timestamp formatted numerically for printing purposes
STRING_FUNCTION printStamp(STRING stamp64$)
{	
	STRING tempStamp$[32];
	LONG_INTEGER hi32, lo32;

	//if this string isn't 64 bits (8 bytes), it's not valid
	if (len(stamp64$) <> 8)
		return ("INVALID");

	hi32 = strToLong(left(stamp64$, 4)); //the first 4 bytes of the string represent the time in seconds
	lo32 = strToLong(right(stamp64$, 4)); //the last 4 bytes represent the fraction of a second

	MakeString(tempStamp$, "%lu.%010lu", hi32, lo32);

	return(tempStamp$);
}

//returns the GMT offset in minutes as a signed integer
//valid range is -720 to +720 (aka +/- 12 hours)
//if the value on the GMT_Offset_Minutes signal going into this module is out of range, we resort to using
//the value stored by the GMTOFFSET console command
SIGNED_INTEGER_FUNCTION calcGMTOffset()
{
	SIGNED_INTEGER	offsetMins;

	//this is to ensure the analog input has the proper sign when we return it
	offsetMins = GMT_Offset_Minutes;
	//PRINT("[NTP.calcGMTOffset()] (offsetMins=%d)\n", offsetMins);

	if((offsetMins S>= -720) && (offsetMins <= 780))
		return(offsetMins);		
	else
		return(GetGMTOffset());
}

//returns the current time as a long integer
//the value of the integer respresents the number of seconds since January 1, 1900 at 12:00:00 AM
LONG_INTEGER_FUNCTION getTimeInSecs()
{
	INTEGER i, cYear, cMon, cDay, cHour, cMin, cSec;
	LONG_INTEGER secs;

	//sample the current date and time NOW
    cYear = GetYearNum();
	cMon = GetMonthNum();
	cDay = GetDateNum();

	cHour = GetHourNum();
	cMin = GetMinutesNum();
	cSec = GetSecondsNum();
    
	secs = 0;

	//years
	//this should work even after 2037 since the 32-bit long integer will wrap around back to 0 in 2037
    for (i = 1900 to (cYear - 1))
		secs = secs + (86400 * (365 +isLeapYear(i)));

	//months
	for (i = 1 to (cMon - 1))
		secs = secs + (86400 * daysInMonth(i, cYear));

    //days
	for	(i = 1 to (cDay - 1))
		secs = secs + 86400;

	//hours
	for (i = 0 to (cHour - 1))
		secs = secs + 3600;

	//minutes
	for (i = 0 to (cMin - 1))
		secs = secs + 60;

	//seconds
	secs = secs + cSec;

	//reverse apply daylight savings correction
	if (GetDST() = 1)
		secs = secs - 3600;

	//reverse apply GMT offset
	secs = secs - (calcGMTOffset() * 60);

	if(Debug)
		Print("[NTP.getTimeInSecs()][SECS=%lu]\n", secs);

	//and pass this back
	return(secs);
}

//sets the control system clock to the specified timestamp
//the timestamp represents the number of seconds since 1/1/1900
FUNCTION setDateTime(STRING tStamp64$)
{
	STRING round$[1];
	LONG_INTEGER tStamp, tFract;
	INTEGER tYear, tMon, tDay, tHour, tMin, tSec;

	//if this string isn't 64 bits (8 bytes), it's not valid
	if (len(tstamp64$) <> 8)
	{
		if (Debug)
			Print("[NTP.setDateTime()] Invalid Timestamp (%s)\n", printStamp(tStamp64$));

		return;
	}

	ClearBuffer(round$); //make sure this string is clear before starting

	tStamp = strToLong(left(tStamp64$, 4)); //the first 4 bytes of the string represent the time in seconds
	tFract = strToLong(right(tStamp64$, 4)); //the last 4 bytes represent the fraction of a second  

	//if the fraction portion of the timestamp (lower 32 bits) is greater 
	//than .5s (most significant bit is set), tack on another second to the timestamp.
	//set the tRound flag to indicate if the number has been rounded up or not
	if ((tFract >> 31)	= 1)
	{
		tStamp = tStamp + 1;
		round$ = "+";	//set the round flag to indicate the time was rounded up by 1 second
    }

	if (Debug)
		Print("[NTP.setDateTime()][TIMESTAMP=%lu]\n", tStamp);

	//apply GMT offset before calculating the local time
	tStamp = tStamp + (calcGMTOffset() * 60);

	//apply daylight savings by adding an hour (if necessary)
	if(GetDST() = 1)
		tStamp = tStamp + 3600;

	//if the most significant bit of the timestamp is set, assume we are in the era 1968-2035
	//otherwise assume we are 2036 and beyond.  prior to 1968 is not supported.
	if ((tStamp >> 31) = 1)
		tYear = 1900; 
	else
		tYear = 2036;

	tMon = 1;
	tDay = 1;

	tHour = 0;
	tMin = 0;
	tSec = 0;    

	//calculate how many years worth of seconds we have
	//60s x 60m x 24h = 86400s in one day
	while (tStamp > (86400 * (365 + isLeapYear(tYear))))
	{
		tStamp = tStamp - (86400 * (365 + isLeapYear(tYear)));
		tYear = tYear + 1;		
	}

    //now that we have less than a year's worth of seconds remaining, figure out how many months we have left
	while (tStamp > (86400 * daysInMonth(tMon, tYear)))
	{
		tStamp = tStamp - (86400 * daysInMonth(tMon, tYear));
		tMon = tMon + 1;
	}		            

	//do the same for the day of the month
	while (tStamp >= 86400)
	{
		tStamp = tStamp - 86400;
		tDay = tDay + 1;
	}

	//then hours
    while (tStamp >= 3600)
	{
		tStamp = tStamp - 3600;
		tHour = tHour + 1;
	}

	//then minutes
    while (tStamp >= 60)
	{
		tStamp = tStamp - 60;
		tMin = tMin +1;
	}

	//and the seconds are whatever is left
	tSec = LowWord(tStamp);  //the LOWWORD() is just a cheap way of casting a long to an int - the value should be the same since at this point it should be 0-59

	if(Debug)
		Print("[NTP.setDateTime()][%02d/%02d/%d][%02d:%02d:%02d%s](from: %s)\n", tMon, tDay, tYear, tHour, tMin, tSec, round$, tempRxIP$);

	if(Logging)
		GenerateUserNotice("[NTP] Setting date and time to %02d/%02d/%02d - %02d:%02d:%02d%s (from: %s)\n",
							tMon, tDay, tYear, tHour, tMin, tSec, round$, tempRxIP$);

	//set the date and time
	SetClock(tHour, tMin, tSec);
	SetDate(tMon, tDay, tYear);
}


//parse data from the time server
//data received from the socket is passed as a string
//if the data is deemed valid, return 1, otherwise 0
INTEGER_FUNCTION processData(STRING data$)
{
    INTEGER leap, vnum, mode;
	STRING origStamp$[8], txStamp$[8];
			 
	//if (Debug)
	//	Print("[NTP.processData()] Data received.\n");

	if (len(data$) < PKT_SIZE)
	{
   		if (Logging)
			GenerateUserWarning("[NTP] NTP Packet smaller than expected (Size: %d bytes)\n", len(data$));
		if (Debug)
			Print("[NTP.processData()] NTP Packet smaller than expected (Size: %d bytes)\n", Len(data$));

		return(0);
	}

	//parse bit fields from the first byte (leap and vnum are only used for debugging)
	leap = byte(data$, 1) & 0xC0; //first 2 bits:	C0 = 11000000
	leap = leap >> 6;	//shift 6 bits to the right

	vnum = byte(data$, 1) & 0x38; //next 3 bits:	38 = 00111000
	vnum = vnum >> 3;	//shift 3 bits to the right

	mode = byte(data$, 1) & 0x07; //last 3 bits:	07 = 00000111

	//parse 64-bit timestamps
	origStamp$ = mid(data$, 25, 8);
	txStamp$ = mid(data$, 41, 8);
	
	//if the response came from a server (mode 4) and the orig timestamp
	//matches the tx timestamp on the packet we sent, adjust the time
	//also, if the LI (leap indicator) field is set to 3, that indicates that
	//the NTP server is in an unsynchronized state - so ignore all incoming data
	if((leap <> 3) && (mode = 4) && (tempStamp$ = origStamp$))
	{
		if (Debug)
			Print("[NTP.processData()] Valid Data Received. [Mode: %d][Vers: %d][Leap: %d][OrigStamp: %s][TxStamp: %s]\n",
									mode, vnum, leap, printStamp(origStamp$), printStamp(tempStamp$));

		CALL setDateTime(txStamp$);
		return(1);
	}
	else
	{
		if (Logging)
			GenerateUserWarning("[NTP] Invalid Data Received. [Mode: %d][Vers: %d][Leap: %d][OrigStamp: %s][TxStamp: %s]\n",
									mode, vnum, leap, printStamp(origStamp$), printStamp(tempStamp$));
		if (Debug)
			Print("[NTP.processData()] Invalid Data Received. [Mode: %d][Vers: %d][Leap: %d][OrigStamp: %s][TxStamp: %s]\n",
									mode, vnum, leap, printStamp(origStamp$), printStamp(tempStamp$));

     	return(0);
	}
}

//sends the actual query by opening a UDP socket to the specified server
//returns 1 if the socket was able to open and the packet was sent
//returns 0 if the socket could not be opened
INTEGER_FUNCTION sendQuery(STRING ip_address$)
{
	INTEGER temp;
	INTEGER leap, mode, vnum;
	STRING txPacket$[PKT_SIZE];
	SIGNED_INTEGER status;

	//make sure the IP address has non-zero length
	if(len(ip_address$) <= 0)
		return(0);

	//populate only the necessary fields
	//for a client request, most of the fields are zeroed out
	leap = 0;	//not used for client queries
	vnum = 3;	//NTP version 3
	mode = 3;	//mode 3 = client

	//set the header bits correctly in the first byte
	temp = LOW((leap << 6) | (vnum << 3) | mode);
	SETSTRING(CHR(temp), 1, txPacket$);

	//create the 64-bit TX Timestamp using the 32-bit value of the current time and all 
	//zeros for the fractional time since the system clock doesn't offer
	//denominations smaller than a second.  doesn't matter anyway. 
    MakeString(tempStamp$, "%s%s", longToStr(getTimeInSecs()), longToStr(0)); 
	
	//set the TX Timestamp
	SETSTRING(tempStamp$, 41, txPacket$);

	//fill bytes 2 through 40 with zeros since these fields aren't required for a query
	for (temp = 2 to 40)
		SetByte(txPacket$, temp, 0x00);

	//open the UDP socket
	status = SocketUDP_Enable(NTPServer, ip_address$, NTP_PORT);

	if (status = 0)
	{
		//send the data
		SocketSend(NTPServer, txPacket$);

		return(1); //operation successful
	}
	else
	{
		if (Debug)
			Print("[NTP.sendQuery()] Unable to open UDP socket to %s (Error: %d)\n", ip_address$, status);

		return(0);  //operation failed
	}
}


/*******************************************************************************************
  Event Handlers
  (Uncomment and declare additional event handlers as needed)
*******************************************************************************************/

//queries the time server for the current time
PUSH SyncTime
{
	if(!Busy)
	{
		Busy = 1;

		currServer = getLastModifiedArrayIndex();

		//try the primary server first
		//if the packet was sent successfully, wait for the NTP server to respond
		if(sendQuery(Server_IP$[currServer]))
		{
			Wait(UDP_TIMEOUT, ServerWait)
			{
				//if we are still waiting after the timeout, try the next server
				ClearBuffer(NTPServer.SocketRxBuf);
				SocketUDP_Disable(NTPServer);

				if (logging)
					GenerateUserWarning("[NTP] NTP server #%d (Address: %s) timed out after %d seconds.\n",
									currServer, Server_IP$[currServer], UDP_TIMEOUT / 100);   
				if (debug)
					Print("[NTP.UpdateTime] NTP server #%d (Address: %s) timed out after %d seconds.\n",
									currServer, Server_IP$[currServer], UDP_TIMEOUT / 100);

				//check to see if this is the last server, if so, print out error messages.
                if(currServer >= NUM_SERVERS)
				{
					//this should always be logged, regardless of the 'logging' parameter
					GenerateUserError("[NTP] Could not reach any NTP servers. Attempted %d servers.\n", currServer);

					if(debug)
						Print("[NTP.UpdateTime] Could not reach any NTP servers. Attempted %d servers.\n", currServer);
				}

				SyncFailed[currServer] = 1;
				ProcessLogic();
				SyncFailed[currServer] = 0;

				currServer = 0;
				Busy = 0;
			}
		}
		else
		{
				if (logging)
					GenerateUserWarning("[NTP] Could not open socket to NTP Server #%d. (IP=%s)\n", currServer, Server_IP$[currServer]);   
				if (debug)
					Print("[NTP.UpdateTime] Could not open socket to NTP Server #%d. (IP=%s)\n", currServer, Server_IP$[currServer]);

				//check to see if this is the last server, if so, print out error messages.
                if(currServer >= NUM_SERVERS)
				{
					//this should always be logged, regardless of the 'logging' parameter
					GenerateUserError("[NTP] Could not reach any NTP servers. Attempted %d servers.\n", currServer);

					if(debug)
						Print("[NTP.UpdateTime] Could not reach any NTP servers. Attempted %d servers.\n", currServer);
				}
				
				SyncFailed[currServer] = 1;
				ProcessLogic();
				SyncFailed[currServer] = 0;
				
				currServer = 0;
				Busy = 0;
		}	
	}
}

//parse data from the time server
SOCKETRECEIVE NTPServer
{	
	SocketGetSenderIPAddress(NTPServer, tempRxIP$);

	//the first 48 bytes of the return data should be the NTP packet
	if (len(NTPServer.SocketRxBuf) >= PKT_SIZE)
	{	
		if(processData(left(NTPServer.SocketRxBuf, PKT_SIZE)))
		{
			CancelWait(ServerWait);
		
			ClearBuffer(NTPServer.SocketRxBuf);
			SocketUDP_Disable(NTPServer);

			SyncSuccessful[currServer] = 1;
			ProcessLogic();
			SyncSuccessful[currServer] = 0;			

			currServer = 0;
			Busy = 0;	
		}	
	}

	if (Debug)
			Print("[NTP.SOCKETRECEIVE] Received data from: %s\n", tempRxIP$);	
}


/*******************************************************************************************
  Main()
  Uncomment and place one-time startup code here
  (This code will get called when the system starts up)
*******************************************************************************************/

FUNCTION main()
{
	//initialize global variables
	currServer = 0;

	ClearBuffer(tempRxIP$);
	ClearBuffer(tempStamp$);
}
